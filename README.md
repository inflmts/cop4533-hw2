# Programming Assignment 2: Greedy Algorithms

COP4533 - Algorithm Abstraction and Design

Daniel Li - 99157575

## Running

You will need a recent version of Python (tested with Python 3.14.3).

`cache.py` reads from the specified file or standard input. Example:

```
./cache.py examples/example.in
```

Example files are in the `examples` directory. There are three pairs
of input and expected output files:

* `example.in` / `example.out`
* `example2.in` / `example2.out`
* `example3.in` / `example3.out`

## Input and Output

The input format is:

```
k m
r1 r2 r3 ... rm
```

where:

* k = cache capacity
* m = number of requests
* r1, ..., rm = integer request IDs

The output format is:

```
FIFO  : <number_of_misses>
LRU   : <number_of_misses>
OPTFF : <number_of_misses>
```

where the three policies are:

* FIFO = first-in-first-out
* LRU = least recently used
* OPTFF = Belady's farthest-in-future, optimal offline

## Empirical Comparison

Here are the number of misses reported for each policy
when applied to the three example files:

| Input File | k | m   | FIFO | LRU | OPTFF |
| ---------- | - | --- | ---- | --- | ----- |
| example    | 5 | 50  | 28   | 29  | 20    |
| example2   | 5 | 100 | 56   | 55  | 33    |
| example3   | 3 | 100 | 70   | 68  | 52    |

* OPTFF always has the fewest misses.
* The miss rates of FIFO and LRU are similar.

## Bad Sequence for LRU or FIFO

For ( k = 3 ), it is possible for OPTFF to incur strictly fewer misses
than LRU or FIFO. `examples/example3.in` is one such sequence.
A simpler example is:

```
1 2 3 4 1 2 3 4
```

This results in 8 misses for LRU and FIFO, and 5 misses for OPTFF.

## Proof of OPTFF Optimality

Let A be an optimal offline algorithm for minimizing the number of misses.
Let ( a1, ..., am ) be the sequence of evictions generated by A
and ( e1, ..., em ) be the sequence of evictions generated by OPTFF.
Suppose A and OPTFF differ.
Let i be the first position that they differ,
that is, ( ai &ne; ei ).
Up to this point, the contents of the cache are identical for both algorithms;
importantly, both ai and ei are in the cache.
Thus it is possible for A to evict ei instead of ai;
this action alone does not change the number of misses.

There are four cases to consider.
Note that it is not possible for ei to be accessed afterwards but not ai,
as OPTFF would evict ai over ei in this case.
We do not need to consider the cases where ai is evicted because
in the original A, ai has already been evicted.
However, we do need to handle cases where ei is evicted.

* If ei is never accessed afterwards, there will be no further misses
  due to this change.

* If ei would have been evicted before it is next accessed but after ai is accessed,
  whatever would have been evicted when ai was accessed can be evicted now.
  This does not result in further misses because
  the lifetime of this item in the cache increases.

* If ei would have been evicted before it or ai is next accessed,
  ai can be evicted instead.
  The result is the same, with neither ei nor ai in the cache.

* Otherwise, neither ei nor ai would have been evicted before they are next accessed.
  When ei is accessed, this will change from a hit to a miss
  because ei is no longer in the cache,
  but when ai is accessed, this will change from a miss to a hit
  because ai is in the cache.
  There is no net change in the number of misses.

In all cases, the resulting algorithm is at least as optimal as A.

**Recursive step:** The same logic can be applied recursively to all places
where A and OPTFF differ. The resulting algorithm, equivalent to OPTFF,
is at least as optimal as A. Thus OPTFF is optimal.
